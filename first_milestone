import numpy as np 
#import sympy as sp
from functools import reduce
from scipy.linalg import expm

import matplotlib.pyplot as plt

from numpy.typing import ArrayLike
import networkx as nx








def sigma_z(n,j): #must be that n>j

    #assert n>j
     #j must be greater than two?

    #I_2 = np.array([1,0],[0,1])
    I_2 = np.eye(2)
    S_Z = np.array([[1,0],[0,-1]])

    if j == 1:  
        TP_1 = np.eye(1)
    else:
        TP_1 = reduce(np.kron, [I_2]*(j-1)) #this repeats the tensor product of I_2 j-1 times

    
    if j==n:
        TP_2 = np.eye(1)
    else:

        TP_2 = reduce(np.kron, [I_2]*(n-j))

    final = np.kron(np.kron(TP_1,S_Z),TP_2)
    
    return final


#to initialize H_ising now

def H_ising(n,M,kappa):

    #M is the adjacency matrix
    h = np.zeros(n)

    for k in range(0,n): #range doesn't include n, goes from 0 to n-1 here!!

        total = 0

        for j in range(0,n):

            total += -(M[k,j]+M[j,k])

        h[k] = total + kappa

    
    #to find H_ising now
    H = np.zeros((2**n,2**n))
    H_2 = np.zeros((2**n,2**n))
    for k in range(1,n+1):   #1 to n


        H_2 += h[k-1]*sigma_z(n,k)
        

        for j in range(k+1,n+1): #k+1 to n

            H += (M[k-1,j-1]*sigma_z(n,k)@sigma_z(n,j)) 
    
    return (H+H_2)



def Ising_search(H):

    #min_val = float('inf') #this is positive infinity
    
    val_dict = {}    

    val_dict['min_val']= float('inf')
    val_dict['index'] = None             

    for i in range(len(H)):  #H_ising will only have diagonal terms and be a perfect square matrix...

        if H[i,i] < val_dict['min_val']:

            val_dict['min_val'] = H[i,i]
            val_dict['index'] = i

    return val_dict['index']



        







#test code -----------------------------------------------------------------#
M = np.array([[0,1,1,0,0],[0,0,1,0,1],[0,0,0,1,1],[0,0,0,0,0],[0,0,0,0,0]])

J = np.array([[0,1,0],[0,0,1],[0,0,0]])  #3 dim case

H = H_ising(5,M,0.5)

#print(H)

#print("min value is" + str(np.min(H)))

#print(H[19,19])

#print(sigma_z(5,4).shape)

#print(Ising_search(H))

#---------------------------------------------------------------------------#

#time adiabatic problem now



#figure out how wavefunction evolves in time too

def init_psi(n):

    up_state = (1/(2)**0.5)*np.array([[1],[1]])

    initial = up_state
    for i in range(n-1):  #n-1 since 1 counts as its self...
        initial = np.kron(initial,up_state)
    
    return initial



def sigma_j(n,i,choice): #must be that n>j


    #assert n>j
     #j must be greater than two?

    #I_2 = np.array([1,0],[0,1])
    I_2 = np.eye(2)
    
    if choice == 'x':

        S = np.array([[0,1],[1,0]])

    if choice == 'y':

        S = np.array([[0,-1j],[1j,0]])

    if choice == 'z':

        S = np.array([[1,0],[0,-1]])

    if i == 1:  
        TP_1 = np.eye(1)
    else:
        TP_1 = reduce(np.kron, [I_2]*(i-1)) #this repeats the tensor product of I_2 j-1 times

    
    if i==n:
        TP_2 = np.eye(1)
    else:

        TP_2 = reduce(np.kron, [I_2]*(n-i))

    final = np.kron(np.kron(TP_1,S),TP_2)
    
    return final


def sigma_x(n,j): #must be that n>j

    #assert n>j
     #j must be greater than two?

    #I_2 = np.array([1,0],[0,1])
    I_2 = np.eye(2)
    S_X = np.array([[0,1],[1,0]])

    if j == 1:  
        TP_1 = np.eye(1)
    else:
        TP_1 = reduce(np.kron, [I_2]*(j-1)) #this repeats the tensor product of I_2 j-1 times

    
    if j==n:
        TP_2 = np.eye(1)
    else:

        TP_2 = reduce(np.kron, [I_2]*(n-j))

    final = np.kron(np.kron(TP_1,S_X),TP_2)
    
    return final

def Hamiltonian(n,t,t_max,M):

    A = lambda t, t_max: 1 - (t/t_max)

    B = lambda t, t_max: t/t_max


    val = np.zeros((2**n,2**n))
    for i in range(1,n+1):
        val += sigma_x(n,i)

    
    final = A(t,t_max)*val - B(t,t_max)*H_ising(n,M,0.5) #kappa = 0.5

    return final



def adiabatic_evol(t_max, M, n, q=200):  #assume for now k and q are the same as in the eqn...

    W = init_psi(n)  #W for wavefunction...

    vals = np.zeros(q+1)
    dt = t_max/q

    for i in range(0,q):   #we have -1 to include 0 in range

        W = np.dot(expm(-1j*dt*Hamiltonian(n,i*dt,t_max,M)),W)  #is this matrix multiplication?

        

        vals[i] = W


        if np.isnan(W).any():
            print(i)
            break
    return vals



#compare to get probabilities:
# just for specific case of n=5:

#f = adiabatic_evol(1, M, 5)  #is this state normalised?? we can check

#print(f)
#print(f.shape)
#print(init_psi(5).shape)
#print(init_psi(5))

#c = np.linalg.norm(f)

#normalised_f = (1/c)*f

#print(np.linalg.norm(normalised_f))


#build a program to write probabilties 

def ground_wf(n,M: ArrayLike):  #is set to be a covector!

    H = H_ising(n,M,0.5) #kappa set to 0.5

    i = Ising_search(H)

    vector = np.zeros((2**n))

    vector[i] = 1

    return vector






def adiabatic_prob(t_max: list, M: ArrayLike, n, q=150):

    #w_0 = np.conjugate(ground_wf(n,M))  #already conjugated

    w_0 = ground_wf(n,M)

    num_val = len(t_max)

    values = np.zeros((num_val,q+1), dtype = complex)  #might be an issue with num_val value...

    j_index = -1

    for t_m in t_max:
        
        
        j_index += 1

        W = init_psi(n)

        dt = t_m/q

        for i in range(0,q+1):   #we have -1 to include 0 in range #original range(q,-1,-1)


            
            W = np.dot(expm(-1j*dt*Hamiltonian(n,i*dt,t_m,M)),W)  #is this matrix multiplication?

            #calculate probabilty
            norm = abs(np.vdot(W,W))  #norm should be conserved...since unitary operator?

            

            prob = abs(((np.vdot(np.conjugate(W),w_0))))**2/norm  #this should be correct...

            #print("this is the prob"+str(prob))

            #print(W.shape)

            #print(abs(np.vdot(w_0,W)**2/np.vdot(W,W)))

            
            

            values[j_index, i] = np.real(prob)


            if np.isnan(W).any():
                print("values too large, stopped at index: "+str(i))
                break
    return values


t_max = [1,2,5,10,100]


###v = adiabatic_prob(t_max, M, 5)

#print(v)


#print(len(v[0]))   #for given example, is 3 x 1001  3 rows, 1001 columns for q =1000


def plot_prob(vals):

    rows = len(vals)

    x = np.linspace(0,1,len(vals[0]))


    for j in vals:

        for i in range(rows):

            v = vals[i]
       
            plt.plot(x,v)

    plt.ylabel("Success Probability")

    plt.xlabel("1/t_max")

    plt.show()


#plot_prob(v)


def plot_wavefunction_evolution(vals):

    iterations = len(vals)


    x = list(iterations)

    plt.plot(x,vals)

    plt.xlabel("iterations")

    plt.ylabel("wavefunction")

    plt.show()

#values = adiabatic_evol(10, M, 5, 200)

#plot_wavefunction_evolution(values)




    


# now we want to measure the annealing schedule based on N:

#first we want to construct a random adjacency matrix,M , of dimension N:

def generate_adjacency_matrix(n):

    M = np.zeros((n,n), dtype = int)  #put dtype to ensure no floats in zero entries


    for i in range(n):
        for j in range(i+1,n):  #add i+1 to ensure they aren't self connected - can this be added though??

            edge = np.random.choice([0,1])

            M[i,j] = edge

    return M


def visualize_graph(adj_matrix):

    graph = nx.from_numpy_matrix(adj_matrix)

    plt.figure(figsize=(8, 8))  # Set the figure size
    nx.draw(
        graph,
        with_labels=True,            # Show node labels
        node_color='skyblue',        # Node color
        node_size=500,               # Node size
        edge_color='gray',           # Edge color
        font_size=10,                # Font size for labels
    )
    plt.title("Graph Visualization")
    plt.show()




def verify_min_value_H(H_ising):  #this function returns a tuple!!

    minimum_value = np.min(H_ising)

    i = Ising_search(H_ising)

    if minimum_value == H_ising[i,i]:
        return True, minimum_value
    else:

        return False







#test generate and visualize the graph!!

#n = 6

#g = generate_adjacency_matrix(n)

##visualize_graph(g)

#H = H_ising(n,g,0.5)

#print(verify_min_value_H(H))   H is always diagonal!

#------------------------------------------







def graph_annealing_time_against_N(q,list_of_dimensions,t_max_step):


    tau = np.zeros(len(list_of_dimensions))

    for index, n in enumerate(list_of_dimensions):

        

        g = generate_adjacency_matrix(n)

        w_0 = ground_wf(n,g)

        
        tau_index = index
        

        t_max = 10  #start with this for t_max?

        success = False

        while success == False:

            W = init_psi(n)

            

            dt = t_max/q

            for i in range(0,q+1):

                W = np.dot(expm(-1j*dt*Hamiltonian(n,i*dt,t_max,M)),W)  

            #calculate probabilty
                norm = abs(np.vdot(W,W))  #norm should be conserved...since unitary operator?
                prob = abs(((np.vdot(np.conjugate(W),w_0))))**2/norm
                #print(prob)
                if prob >= 0.90:
                    print("success")
                    success = True

                    tau[tau_index] = t_max

                    break
            print("increase")
            t_max += t_max_step

    x_val = list_of_dimensions

    y_val = tau

    plt.plot(x_val,y_val)

    plt.show()

                    





#l = [3,4,5,6,7]

#graph_annealing_time_against_N(50,l,10)


t_max = [1,5,50,100,1000,10000]

n = 4

g = generate_adjacency_matrix(n)

visualize_graph(g)   

plot_prob(adiabatic_prob(t_max,g,n))


#PROBLEM!! it doesn't always work - is that since the gap gets too small - it sometimes goes to half or an incomplete probability for example... does that mean required annealing time is very long?



# try create something that for a given g will calculate the energy gap - and if is above a certain annealing amount, quit the annealing

















    





















